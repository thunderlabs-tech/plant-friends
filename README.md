# Plant Friends

Keep your plants happy by tracking and caring for their needs.

- Production app: https://plantfriends.thunderlabs.tech

## Monorepo Project Structure

This project contains all relevant code for Plant Friends deployment: client apps, server functions, etc.

We use Yarn to manage multiple projects in one repository (known as "workspaces" in Yarn terminology).

See the README in individual workspaces for project-specific info.

## Principles / Conventions

- Keep the UI tree shallow
- Keep configuration in package.json
- Avoid merge commits, but preserve meaningful commit history
- Don't enable linter warnings - either make it an error or disable the rule
- Resolve console errors immediately
- Github issue/card format:
  - **Context** describes:
    - The situation the user is in which motivates the solution described in the issue
    - Any extra information relevant to the reader that they might not otherwise be aware of (other affected systems
      etc)
  - **Proposed Solution**:
    - Describes the solution the author has in mind
    - It's phrased as "proposed" so that if the person working on the card comes up with a better solution they can
      implement that instead, as long as it solves the problem described in the issue
- Naming:
  - Constants set by environment variables use scream case (e.g. `REACT_APP_API_KEY`), as do the environment variables themselves
  - All other constants (even when exported) use the same casing as variables, camelCase (e.g. `const enterTheDragon`)
  - Class and component names use PascalCase (e.g. `PlantAvatar`)
  - TypeScript type aliases use PascalCase (e.g. `Override<X, Y>`)
  - Only uppercase the first letter in an acronym (e.g. `HttpRequest`)
  - Use `at` suffix for properties containing a time value (e.g. `createdAt`)
- Modules:
  - Name files the same as their default export
  - Prefer single exports
  - Only export one component per module (multiple components per module are acceptable if only one is exported)
- Store scripts in `bin/` instead of `package.json`
  - By convention the commands `npm start` and `npm test` run the corresponding script string from `package.json`. Over time people have started adding all relevant scripts as strings in `package.json`, which is not a good medium for them since it unnecessarily loads an entire NodeJS virtual machine just to read the strings out of `package.json` and forces you to write all your scripts as single lines.

## Local Development Environment

1. Install the Amplify CLI globally (running the CLI fails if you install it locally in the project)
   - `yarn install -g @aws-amplify/cli`
2. Install dependencies
   - `yarn install`
3. Check out an Amplify environment
   - `amplify env checkout dev`

You can optionally scaffold a mock AWS environment using `amplify mock` ([see documentation](https://docs.amplify.aws/cli/usage/mock)).

## Project Scripts

Can be found in the `bin/` directories. Github- and Amplify-specific scripts are prefixed with their name.

All scripts execute in their parent directory so relative paths (e.g. `src/`) will be correct regardless of where the script is executed from. Common setup is stored in `bin/.include.sh`.

## Continuous Integration with Github

Continuous integration is managed using Github workflows. See [`.github/workflows/web-app-ci.js.yml`](.github/workflows/web-app-ci.js.yml), which invokes [`bin/github-ci`](bin/github-ci).

## Continuous Deployment

Continuous deployment is managed by Amplify and administered via the [Amplify Dashboard](https://eu-central-1.console.aws.amazon.com/amplify/home?region=eu-central-1&code=8bab87709196a7ed216c#/d1rae0x5ejtmb6).

Find build configuration in [amplify.yml](amplify.yml).

## Amplify

We use the AWS Amplify framework for deployment, hosting, CDN, routing, persistence, server-side functions, storage, etc. The more important functions are listed here. See the Amplify documentation for the rest.

- [Plant Friends Amplify Console](https://eu-central-1.console.aws.amazon.com/amplify/home?region=eu-central-1#/d1rae0x5ejtmb6)
- `amplify console` opens the lower-level management UI
- `amplify api console` opens the AWS GraphQL explorer for the API

NOTE: if you get a "not found" error, it might be because AWS has defaulted to the wrong region. Switch to `eu-central-1 (Frankfurt)` and try again.

### Environments

- Production: https://plantfriends.thunderlabs.tech
  - Deployed automatically from branch `master`
- Staging: https://plantfriends-staging.thunderlabs.tech
  - Deployed automatically from branch `staging`

You can provision your own environment for development using `amplify env add`.

You can set sensitive environment variables in the Amplify Console.

### aws-exports.js

This file includes access keys for the various connected AWS services and is generated by the Amplify CLI when you run `amplify env checkout <name>`.

A dummy file is committed to the repository which allows building the source (to pass CI) but throws an error when loaded at run-time.

### Persistence

The GraphQL schema is stored in: [amplify/backend/api/plantfriends/schema.graphql](amplify/backend/api/plantfriends/schema.graphql).

Update the remote Amplify database with local schema changes using `amplify api push`, or pull the remote schema (overriding any local changes) using `amplify api pull`.

### Code Generation

Regenerate API types, query and mutations from the GraphQL schema using [bin/codegen](bin/codegen).

Generated code is committed to the repository so that CI can run independently of Amplify. This is unfortunate, hopefully we can find a better solution in the future.

### Authentication / Authorization

User signup and login is provided by [Amplify Auth](https://docs.amplify.aws/start/getting-started/auth/q/integration/react) and the [`withAuthenticator()`](https://aws-amplify.github.io/amplify-js/api/globals.html#withauthenticator) HOC.

User data is stored in Amazon Cognito User Pools.

## User stories

These are implementation-agnostic descriptions of how the app fits into users' lives. We record them
here to provide direction for future features and UX design, without constraining us to a specific
implementation.

- When I get up in the morning
  - I want to water my plants
  - Eg. by seeing a list of which plants need water
  - And checking off each one as I water it
- When one of my plants is dead
  - I want to avoid getting reminders about it
  - E.g. by removing it from the list
- When one of my plants looks a bit dry
  - I want to know when it was last watered
  - E.g. by using filtering the list by its name
  - Or by navigating by the room it's in
- When I'm going away for a few days
  - I want to make sure my plants will have enough water
  - E.g. by seeing a calendar / time ordered list of when plants will need water
  - So that I can water them before I leave
- When I'm on a different device
  - I want to have access to my data
  - E.g. by authenticating as the same user
- When I'm using another app which can use my data / I want to back up my data
  - I want to be able to download my data
  - E.g. as CSV
- When my plants need fertilizer
  - I want to fertilize my plants
  - E.g. by seeing a list of which plants need to be fertilized
- When I have a new plant / a plant is unwell
  - I want to make sure it has the sun / temperature / humidity it needs
  - E.g. by seeing data about the type of plant it is and its needs
- When I'm reminded to water a plant but its soil is still damp
  - I want to not be reminded to water it until it dries out a bit
  - E.g. by skipping that reminder and increasing the time between watering reminders
- When one of my plants needs water but I haven't been reminded yet
  - I want to make it gets enough water
  - E.g. by watering it and reducing the time between waterings
